# rucio-task-manager

A modular and extensible framework for performing tasks on a Rucio datalake.

# Architecture

```
  ├── Dockerfile
  ├── etc
  │   ├── helm
  │   ├── docker
  │   └── tasks
  │      └── <deployment>
  │         └── probes
  │         └── reports
  │         └── sync
  │         └── tests
  ├── LICENSE
  ├── Makefile
  ├── README.md
  ├── requirements.txt
  └── src
      |── common
      └── tasks
         └── probes
         └── reports
         └── sync
         └── tests

```

Fundamentally, this framework is a task scheduler for Rucio. A "task" is any operation or sequence of operations that 
can be performed on the datalake.

Within this framework, a task is defined by two parts: the logic and the definition. Task logic should be sufficiently 
abstracted & parameterised so as to clearly demarcate these two parts, allowing for easy re-use and chaining of tasks.

The source for the task logic is kept in `src/tasks`. The structure of `src/tasks` takes the following 
format: `<task_type>/<task_name>.yml` where, for consistency, `<task_type>` should be one of:

- probes (cluster health, uptime etc.)
- reports
- sync (syncing functionality, e.g. databases)
- tests

Other categories may be added as needed.

Task definitions are written in yaml and stored in `etc/tasks`. Each definition contains fields to specify the task 
logic module to be used and any necessary corresponding arguments. The structure of `etc/tasks` takes the following 
format: `<deployment>/<task_type>/<task_name>.yml`.

A Helm chart for deployment to a kubernetes cluster is kept in `etc/helm`.

# Usage

This framework is designed to be run in a dockerised environment. It currently supports authentication with the datalake via userpass, x509 and OpenID Connect. Note that with only userpass authentication, some operations e.g. upload/delete on Grid managed storage sites will be restricted.

Images should be built off a preexisting dockerised Rucio client image. This image could be the de facto standard provided by the Rucio maintainers (https://github.com/rucio/containers/tree/master/clients), included in the root `Makefile` as target "rucio", or an extended image. Client images can be extended to contain the prerequisite certificate bundles, VOMS setup and Rucio template configs for a specific datalake.

Extended images currently exist for _prototype skao_ datalakes. Builds for other datalake instances can be enabled by adding a new `docker build` routine as a new target in the root `Makefile` with the corresponding build arguments for the base client image and tag.

When a change is made to either the logic or definition (unless only the definition has changed and is being supplied as an url in the **TASK_FILE_PATH**), the image will need to be rebuilt, e.g. for skao images:

```bash
eng@ubuntu:~/rucio-analysis$ make skao
```

## Required environment variables

To use the framework, it is first necessary to set a few environment variables. A brief description of each is given below:

- **RUCIO_CFG_AUTH_TYPE**: the authentication type (userpass||x509||oidc)
- **TASK_FILE_PATH**: the relative path from the package root to the task file or url

Depending on whether they are already set in the image's baked-in `rucio.cfg`, the following may need to be set:

- **RUCIO_CFG_RUCIO_HOST**: the Rucio server host
- **RUCIO_CFG_AUTH_HOST**: the Rucio auth host
- **RUCIO_CFG_ACCOUNT**: the Rucio account under which the tasks are to be performed

Additionally, there are authentication type dependent variables that must be set.

### Authentication by username/password

For "userpass" authentication, the following variables are also required:

- **RUCIO_CFG_USERNAME**: username
- **RUCIO_CFG_PASSWORD**: the corresponding password for the user

### Authentication by X.509

For "x509" authentication, it is possible to supply the necessary credentials via two methods.

If the key/certificate values are stored in environment variables as plaintext, e.g. coming from a k8s secret, then:

- **RUCIO_CFG_CLIENT_CERT_VALUE**: a valid X.509 certificate
- **RUCIO_CFG_CLIENT_KEY_VALUE**: a valid X.509 key

Alternatively, the paths to the key/certificate can be held in the following variables:

- **RUCIO_CFG_CLIENT_CERT**: path to a valid X.509 certificate 
- **RUCIO_CFG_CLIENT_KEY**: path to a valid X.509 key
- **VOMS**: the virtual organisation that the user belongs to

but the key/certificate **must be volume mounted to these locations**.

### Authentication by OpenID Connect

For "oidc" authentication, it is possible to supply the necessary credentials via two methods.

The first method assumes that the user has a client configuration generated by the `oidc-agent` tool. This client should have a refresh token attached to it in order that access tokens can be generated when required. This is useful if asynchronous cronjobs need to be run.

The encryped oidc-agent client configuration is stored in an environment variable as plaintext:

- **OIDC_AGENT_AUTH_CLIENT_CFG_VALUE**: an encrypted oidc-agent client with refresh token
- **OIDC_AGENT_AUTH_CLIENT_CFG_PASSWORD**: the password to decrypt this client

The second method assumes that the user has an access token:

- **OIDC_ACCESS_TOKEN**: an encrypted oidc-agent client with refresh token

Both methods require the Rucio account to be explicitly set:

- **RUCIO_CFG_ACCOUNT**: the Rucio account under which the tasks are to be performed

Depending on whether they are already set in the image's baked-in `rucio.cfg`, the following may need to be set:

- **RUCIO_CFG_OIDC_SCOPE**: list of OIDC scopes
- **RUCIO_CFG_OIDC_AUDIENCE**: list of OIDC audiences

## Examples

In all the examples below, it is also possible to override other `RUCIO_*` environment variables. If they are not explicitly supplied, they will be taken from the `rucio.cfg`.

### userpass

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=userpass \
-e RUCIO_CFG_USERNAME=$RUCIO_CFG_USERNAME \
-e RUCIO_CFG_PASSWORD=$RUCIO_CFG_PASSWORD \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
--name=rucio-analysis rucio-analysis:skao
```

Additionally, for development purposes, it is possible to mount the package from the host directly into the container provided you have exported the project's root directory path as **RUCIO_ANALYSIS_ROOT**, e.g.:

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=userpass \
-e RUCIO_CFG_ACCOUNT=$RUCIO_CFG_ACCOUNT \
-e RUCIO_CFG_USERNAME=$RUCIO_CFG_USERNAME \
-e RUCIO_CFG_PASSWORD=$RUCIO_CFG_PASSWORD \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
-v $RUCIO_ANALYSIS_ROOT:/opt/rucio-analysis \
--name=rucio-analysis rucio-analysis:skao
```

With this, it is not required to rebuilt the image everytime it is run.

### x509

#### By passing in key/certificate values as plaintext

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=oidc \
-e RUCIO_CFG_CLIENT_CERT_VALUE="`cat $RUCIO_CFG_CLIENT_CERT`" \
-e RUCIO_CFG_CLIENT_KEY_VALUE="`cat $RUCIO_CFG_CLIENT_KEY`" \
-e VOMS=skatelescope.eu \
-e RUCIO_CFG_ACCOUNT=root \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
--name=rucio-analysis rucio-analysis:skao
```

#### By passing in key/certificate paths

For X.509 authentication with Rucio via paths you must bind the certificate credentials to a volume inside the container, e.g.:

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=x509 \
-e RUCIO_CFG_ACCOUNT=$RUCIO_CFG_ACCOUNT \
-e RUCIO_CFG_CLIENT_CERT=/opt/rucio/etc/client.crt \
-e RUCIO_CFG_CLIENT_KEY=/opt/rucio/etc/client.key \
-e VOMS=skatelescope.eu \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
-v $RUCIO_CFG_CLIENT_CERT:/opt/rucio/etc/client.crt \
-v $RUCIO_CFG_CLIENT_KEY:/opt/rucio/etc/client.key \
--name=rucio-analysis rucio-analysis:skao
```

### oidc

#### By passing in an oidc-agent client configuration

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=$RUCIO_CFG_AUTH_TYPE \
-e RUCIO_CFG_ACCOUNT=$RUCIO_CFG_ACCOUNT \
-e OIDC_AGENT_AUTH_CLIENT_CFG_VALUE="`cat ~/.oidc-agent/<client_name>`" \
-e OIDC_AGENT_AUTH_CLIENT_CFG_PASSWORD=$OIDC_AGENT_AUTH_CLIENT_CFG_PASSWORD \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
--name=rucio-analysis rucio-analysis:skao
```

#### By passing in an access token

For OIDC authentication with Rucio via an access token:

```bash
eng@ubuntu:~/rucio-analysis$ docker run --rm -it \
-e RUCIO_CFG_AUTH_TYPE=$RUCIO_CFG_AUTH_TYPE \
-e RUCIO_CFG_ACCOUNT=$RUCIO_CFG_ACCOUNT \
-e OIDC_ACCESS_TOKEN="$OIDC_ACCESS_TOKEN" \
-e TASK_FILE_PATH=etc/tasks/stubs.yml \
--name=rucio-analysis rucio-analysis:skao
```

# Deployment

## Kubernetes

Deployment in a kubernetes cluster is managed by Helm. 

A rucio-analysis image must be built, tagged and pushed to a location accessible to the cluster, e.g. for SKAO's gitlab:

```bash
eng@ubuntu:~/rucio-analysis$ docker build .
eng@ubuntu:~/rucio-analysis$ docker tag rucio-analysis:skao registry.gitlab.com/ska-telescope/src/ska-rucio-prototype/ska-rucio-analysis-client:latest
eng@ubuntu:~/rucio-analysis$ docker push registry.gitlab.com/ska-telescope/src/ska-rucio-prototype/ska-rucio-analysis-client:latest
```

As is standard procedure for Helm, the values in `etc/helm/values.yaml` can be adjusted accordingly. 

Variables to be directly assigned as environment variables to the container can be specified in the `config` section, e.g.

```yaml
config:
  RUCIO_CFG_RUCIO_HOST: https://srcdev.skatelescope.org/rucio-dev
  RUCIO_CFG_AUTH_HOST: https://srcdev.skatelescope.org/rucio-dev
```

Secrets such as certificates and keys can be created, e.g. 

```bash
$ kubectl create secret generic oidc-agent-auth-client --from-file=cfg=/path/to/file --from-literal=password=<password>
```
then specified in the `secrets` section:

```yaml
secrets:
  - name: OIDC_AGENT_AUTH_CLIENT_CFG_VALUE
    fromSecretName: oidc-agent-auth-client
    fromSecretKey: cfg
  - name: OIDC_AGENT_AUTH_CLIENT_CFG_PASSWORD
    fromSecretName: oidc-agent-auth-client
    fromSecretKey: password
```

to be similarly assigned as environment variables in the container.

Cronjobs for tasks can be scheduled by adding a new entry to the `cronjobs` section, e.g.

```yaml
cronjobs:
  - name: <task_name>
    minute: "0"
    hour: "*"
    day: "*"
    month: "*"
    weekday: "*"
    task_file_path: "path/to/test"
    disabled: no
```

Task files can either be specified as a path, `task_file_path`, or inline as yaml under `task_file_yaml`. If both are specified, then the inline yaml takes preference.

It is possible to substitute secrets into tasks using j2 syntax ( `{{ VARIABLE }}`), e.g.

```bash
$ kubectl create secret generic task-stubs --from-literal=text=HelloWorld
```

```yaml
secrets:
  - name: TASK_STUBS_TEXT
    fromSecretName: task-stubs
    fromSecretKey: text
    
cronjobs:
  - name: stubs
    minute: "*/15"
    hour: "*"
    day: "*"
    month: "*"
    weekday: "*"
    task_file_yaml: 
      test-hello-world-stub:
        description: Test hello world stub
        module_name: tasks.stubs
        class_name: StubHelloWorld
        enabled: true
        args:
        kwargs:
          text: {{ TASK_STUBS_TEXT }}
    disabled: yes
```

# Development

## Creating a new task

The procedure for creating a new tests is as follows:

1. Take a copy of the `TestStubHelloWorld` class stub in `src/tasks/stubs.py` and rename both the file and class name.
2. Amend the entrypoint `run()` function as desired. Functionality for communicating with Rucio either by the CLI or API is provided via the wrapper and helper functions in `rucio/wrappers.py` and `rucio/helpers.py` respectively. Alternatively, you can use the client functions directly. Example usage can be found in the `StubRucioAPI` class stub in `src/tasks/stubs.py`.
3. Create a new task definition file e.g. `etc/tasks/test.yml` copying the format of the `test-hello-world-stub` definition in `etc/tasks/stubs.yml`. A task has the following mandatory fields:
   - `module_name` (starting from and including the `tasks.` prefix) and `class_name`, set accordingly to match the modules/classes redefined in step 1,
   - `args` and `kwargs` keys corresponding to the parameters injected into the task's entry point `run()`,
   - `description`, and
   - `enabled`.
